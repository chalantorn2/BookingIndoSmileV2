<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostgreSQL to MySQL Converter (Client-Side)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; line-height: 1.5; color: #333; }
        h1 { margin-bottom: 1rem; }
        .card { border: 1px solid #ddd; border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 600; }
        input[type="file"] { display: block; width: 100%; border: 1px solid #ccc; padding: 0.5rem; border-radius: 4px; }
        button { background-color: #007bff; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer; font-size: 1rem; font-weight: 600; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        #status { margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; border: 1px solid #eee; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto; }
        .progress-bar-container { width: 100%; height: 20px; background-color: #eee; border-radius: 4px; overflow: hidden; margin-top: 1rem; display: none; }
        .progress-bar { height: 100%; background-color: #28a745; width: 0%; transition: width 0.3s ease; }
        .error { color: #dc3545; }
        .success { color: #28a745; }
    </style>
</head>
<body>

    <h1>PostgreSQL to MySQL Converter</h1>

    <div class="card">
        <p>Select your Supabase PostgreSQL dump file (<code>.sql</code>). This tool processes everything locally in your browser.</p>
        <div class="form-group">
            <label for="sqlFile">Upload SQL Dump:</label>
            <input type="file" id="sqlFile" accept=".sql">
        </div>
        <button id="convertBtn" disabled>Convert to MySQL</button>
        <div class="progress-bar-container" id="progressBarContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>

    <div id="status">Waiting for file...</div>

    <script>
        const sqlFileInput = document.getElementById('sqlFile');
        const convertBtn = document.getElementById('convertBtn');
        const statusDiv = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');

        let fileContent = '';

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            let color = 'black';
            if (type === 'error') color = '#dc3545';
            if (type === 'success') color = '#28a745';
            statusDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            statusDiv.scrollTop = statusDiv.scrollHeight;
        }

        sqlFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                convertBtn.disabled = false;
                log(`Selected file: ${e.target.files[0].name}`);
            } else {
                convertBtn.disabled = true;
            }
        });

        convertBtn.addEventListener('click', async () => {
            const file = sqlFileInput.files[0];
            if (!file) return;

            convertBtn.disabled = true;
            progressBarContainer.style.display = 'block';
            progressBar.style.width = '0%';
            statusDiv.innerHTML = '';
            log("Starting conversion process...");

            // Use FileReader to read the file
            const reader = new FileReader();
            reader.onload = function(e) {
                fileContent = e.target.result;
                log(`File loaded. Size: ${(fileContent.length / 1024 / 1024).toFixed(2)} MB`);
                setTimeout(processFile, 100); // Allow UI to update
            };
            reader.onerror = function() {
                log("Error reading file", 'error');
                convertBtn.disabled = false;
            };
            reader.readAsText(file);
        });

        async function processFile() {
            try {
                const lines = fileContent.split(/\r?\n/);
                let outputSQL = "-- MySQL Dump generated by Client-Side Converter\n";
                outputSQL += "SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\n";
                outputSQL += "START TRANSACTION;\n";
                outputSQL += "SET time_zone = \"+00:00\";\n";
                outputSQL += "-- TODO: Uncomment the following lines to create and use a specific database\n";
                outputSQL += "-- CREATE DATABASE IF NOT EXISTS \`booking_indo_smile\`;\n";
                outputSQL += "-- USE \`booking_indo_smile\`;\n\n";

                let currentMode = 'NONE'; // NONE, CREATE_TABLE, COPY
                let currentTableName = '';
                let currentColumns = '';
                let createTableBuffer = '';
                let copyBuffer = [];
                
                // Tables to process (whitelist to verify public schema)
                // We will try to process all 'public.' tables we find
                
                const totalLines = lines.length;
                let processedLines = 0;

                for (let i = 0; i < totalLines; i++) {
                    // Progress update every 1000 lines
                    if (i % 2000 === 0) {
                        const percent = Math.round((i / totalLines) * 100);
                        progressBar.style.width = `${percent}%`;
                        await new Promise(r => setTimeout(r, 0)); // Yield to UI
                    }

                    const line = lines[i];
                    
                    // --- 1. Detect CREATE TABLE ---
                    if (line.startsWith('CREATE TABLE public.')) {
                        currentMode = 'CREATE_TABLE';
                        currentTableName = line.match(/public\.(\w+)/)[1];
                        log(`Found table: ${currentTableName}`);
                        createTableBuffer = `CREATE TABLE \`${currentTableName}\` (\n`;
                        continue;
                    }

                    if (currentMode === 'CREATE_TABLE') {
                        if (line.startsWith(');')) {
                            // End of CREATE TABLE
                            createTableBuffer += `) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n`;
                            outputSQL += createTableBuffer;
                            currentMode = 'NONE';
                            createTableBuffer = '';
                        } else {
                            // Convert column definitions
                            let colLine = line.trim();
                            if (colLine === '(') continue;
                            
                            // Remove comments if any
                            // Replace Types
                            // Replace Types
                            colLine = colLine
                                .replace(/character varying\((\d+)\)/g, 'VARCHAR($1)') // VARCHAR with length
                                .replace(/character varying/g, 'VARCHAR(255)') // Default VARCHAR (no length)
                                .replace(/varchar\((\d+)\)/gi, 'VARCHAR($1)') // Normalize VARCHAR with length
                                .replace(/varchar\s+/gi, 'VARCHAR(255) ') // Normalize bare VARCHAR followed by space
                                .replace(/varchar,/gi, 'VARCHAR(255),') // Normalize bare VARCHAR followed by comma
                                .replace(/varchar$/gi, 'VARCHAR(255)') // Normalize bare VARCHAR at end
                                .replace(/text/g, 'TEXT')
                                .replace(/timestamp with time zone/g, 'DATETIME')
                                .replace(/timestamp without time zone/g, 'DATETIME')
                                .replace(/timestamp/g, 'DATETIME')
                                .replace(/bigint/g, 'BIGINT')
                                .replace(/integer/g, 'INT')
                                .replace(/numeric/g, 'DECIMAL')
                                .replace(/boolean/g, 'TINYINT(1)')
                                .replace(/uuid/g, 'CHAR(36)')
                                .replace(/jsonb/g, 'JSON')
                                .replace(/json/g, 'JSON')
                                .replace(/ARRAY/g, 'JSON') 
                                .replace(/DEFAULT now\(\)/gi, 'DEFAULT CURRENT_TIMESTAMP')
                                .replace(/DEFAULT CURRENT_TIMESTAMP\(\)/gi, 'DEFAULT CURRENT_TIMESTAMP');

                            // Remove PostgreSQL casts (e.g. 'pending'::character varying)
                            colLine = colLine.replace(/::[\w\s()]+/g, '');

                            // Convert Boolean Defaults
                            colLine = colLine.replace(/DEFAULT true/i, 'DEFAULT 1').replace(/DEFAULT false/i, 'DEFAULT 0');

                            // Remove specifics
                            colLine = colLine.replace(/generated always as identity/i, 'AUTO_INCREMENT');
                            colLine = colLine.replace(/generated by default as identity/i, 'AUTO_INCREMENT');

                            // Handle specific column 'key' which is reserved
                            if (colLine.match(/^\s*key\s+/i)) {
                                colLine = colLine.replace(/^\s*key\s+/i, ' `key` ');
                            }

                            // Convert Postgres ARRAY CHECK constraints to MySQL IN checks
                            // Example: CHECK (((status)::TEXT = ANY ((ARRAY['pending'::character varying, ...])::text[])))
                            // Target: CHECK (`status` IN ('pending', ...))
                            if (colLine.includes('CHECK')) {
                                const checkMatch = colLine.match(/CHECK \(\(\((\w+)\).*?ARRAY\[(.*?)\]/);
                                if (checkMatch) {
                                    const field = checkMatch[1];
                                    let values = checkMatch[2]; 
                                    // Clean up values: 'paid'::character varying -> 'paid'
                                    values = values.replace(/::[\w\s()]+/g, '');
                                    colLine = `  CONSTRAINT \`${currentTableName}_${field}_check\` CHECK (\`${field}\` IN (${values}))`;
                                } else {
                                    // If we can't parse it confidently, perform a cleanup or comment it out to prevent errors
                                    // Attempt to catch simple checks or comment out
                                    if(colLine.includes('ANY') || colLine.includes('::text[]')) {
                                         colLine = `-- ${colLine} (Skipped complex PG constraint)`;
                                    }
                                }
                            }
                            
                            // Auto-increment heuristic for 'id' if not explicitly defined
                            // We construct the line to be: `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                            if (colLine.trim().startsWith('`id`') || colLine.trim().startsWith('id')) {
                                // basic check if it's an ID column that should be auto-increment
                                if (colLine.toLowerCase().includes('int') || colLine.toLowerCase().includes('serial') || colLine.toLowerCase().includes('bigint')) {
                                    
                                    // Remove trailing comma for modification transparency
                                    let hasComma = colLine.trim().endsWith(',');
                                    colLine = colLine.replace(/,\s*$/, '');

                                    if (!colLine.toLowerCase().includes('auto_increment')) {
                                        colLine += ' AUTO_INCREMENT';
                                    }
                                    
                                    // MySQL requires AUTO_INCREMENT cols to be Keys.
                                    // We add PRIMARY KEY inline if not present in this line or strictly avoiding duplication if simple
                                    if (!colLine.toLowerCase().includes('primary key') && !createTableBuffer.includes('PRIMARY KEY')) {
                                        colLine += ' PRIMARY KEY'; 
                                    }
                                    
                                    if (hasComma) colLine += ',';
                                }
                            }

                            // Clean up PG specific modifiers and append to buffer
                            // Regex to capture "colname type constraints..."
                            // Handle quoted or unquoted colname
                            const colMatch = colLine.match(/^`?(\w+)`?\s+(.*)/);
                            if (colMatch) {
                                let colName = colMatch[1];
                                let colDef = colMatch[2];
                                
                                // Reserved words check (simplified)
                                if (['order', 'group', 'key', 'limit', 'release', 'index'].includes(colName.toLowerCase())) {
                                    colName = `\`${colName}\``;
                                }

                                createTableBuffer += `  \`${colName}\` ${colDef}\n`;
                            } else if (colLine.trim().startsWith('CONSTRAINT') || colLine.trim().startsWith('PRIMARY KEY')) {
                                createTableBuffer += `  ${colLine}\n`;
                            } else if (colLine.trim().startsWith(')')) {
                                // Catch end of table if missed (unlikely due to earlier check)
                            } else {
                                // Fallback for complex lines not caught
                                createTableBuffer += `  ${colLine}\n`;
                            }
                        }
                        continue;
                    }


                    // --- 2. Detect COPY (Data) ---
                    if (line.startsWith('COPY public.')) {
                        const match = line.match(/COPY public\.(\w+) \((.*?)\) FROM stdin;/);
                        if (match) {
                            currentMode = 'COPY';
                            currentTableName = match[1];
                            currentColumns = match[2]; // e.g., "id, created_at, name"
                            // Sanitize columns for MySQL
                            currentColumns = currentColumns.split(', ').map(c => `\`${c}\``).join(', ');
                            log(`Processing data for: ${currentTableName}`);
                            outputSQL += `TRUNCATE TABLE \`${currentTableName}\`;\n`; // Optional: clear before import
                            continue;
                        }
                    }

                    if (currentMode === 'COPY') {
                        if (line === '\\.') {
                            // End of COPY block
                            if (copyBuffer.length > 0) {
                                outputSQL += `INSERT INTO \`${currentTableName}\` (${currentColumns}) VALUES \n`;
                                outputSQL += copyBuffer.join(',\n') + ';\n';
                                copyBuffer = [];
                            }
                            currentMode = 'NONE';
                        } else {
                            // Parse Data Line
                            const values = line.split('\t');
                            const formattedValues = values.map(val => {
                                if (val === '\\N') return 'NULL';
                                
                                // Booleans
                                if (val === 't') return '1';
                                if (val === 'f') return '0';

                                // Timestamps: Remove +00 or similar timezone info if present to fit DATETIME
                                // Example: 2025-05-24 09:25:37.671+00 -> 2025-05-24 09:25:37.671
                                if (val.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
                                    return `'${val.replace(/\+\d+$/, '').replace(/Z$/, '')}'`;
                                }
                                
                                // Escape single quotes: Replace ' with \' (and start/end quotes)
                                // also escape backslashes
                                let escaped = val.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                                return `'${escaped}'`;
                            });

                            copyBuffer.push(`(${formattedValues.join(', ')})`);

                            // Flush every 500 rows to avoid huge Insert statements
                            if (copyBuffer.length >= 500) {
                                outputSQL += `INSERT INTO \`${currentTableName}\` (${currentColumns}) VALUES \n`;
                                outputSQL += copyBuffer.join(',\n') + ';\n';
                                copyBuffer = [];
                            }
                        }
                        continue;
                    }
                    
                    // --- 3. Handle Sequences (ALTER SEQUENCE ... RESTART WITH) -> AUTO_INCREMENT ---
                    // "SELECT pg_catalog.setval('public.users_id_seq', 7, true);"
                    if (line.includes('SELECT pg_catalog.setval')) {
                         const match = line.match(/public\.(\w+)_id_seq', (\d+)/);
                         if (match) {
                             const table = match[1];
                             const val = parseInt(match[2]) + 1; // Next value
                             outputSQL += `ALTER TABLE \`${table}\` AUTO_INCREMENT = ${val};\n`;
                         }
                    }

                    // --- 4. Handle ALTER TABLE ... ADD CONSTRAINT (PKs/FKs) ---
                    // PostgreSQL dumps keys at the end. MySQL prefers inline or ALTERs.
                    // We need to parse these to ensure PKs exist if not inline.
                    if (line.startsWith('ALTER TABLE ONLY public.')) {
                        // Extract table
                         const match = line.match(/public\.(\w+)/);
                         if(match) {
                             const table = match[1];
                             // Look ahead for "ADD CONSTRAINT ... PRIMARY KEY"
                             // This parser is line-by-line, so we might need a mini-buffer or assume standard pg_dump formatting (indentation)
                             // Usually:
                             // ALTER TABLE ONLY public.users
                             //     ADD CONSTRAINT users_pkey PRIMARY KEY (id);
                             if (lines[i+1] && lines[i+1].trim().startsWith('ADD CONSTRAINT') && lines[i+1].includes('PRIMARY KEY')) {
                                 const constraintLine = lines[i+1];
                                 const keyMatch = constraintLine.match(/PRIMARY KEY \((.*?)\)/);
                                 if (keyMatch) {
                                     outputSQL += `ALTER TABLE \`${table}\` ADD PRIMARY KEY (${keyMatch[1]});\n`;
                                     i++; // Skip next line
                                 }
                             }
                         }
                    }
                }
                
                outputSQL += "\nCOMMIT;\n";
                
                log("Conversion complete!", 'success');
                progressBar.style.width = '100%';
                
                createDownloadLink(outputSQL);

            } catch (err) {
                log(`Error processing file: ${err.message}`, 'error');
                console.error(err);
            } finally {
                convertBtn.disabled = false;
            }
        }

        function createDownloadLink(content) {
            const blob = new Blob([content], { type: 'application/sql' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mysql_converted_${new Date().getTime()}.sql`;
            a.textContent = 'Download Converted File';
            a.className = 'button';
            a.style.display = 'inline-block';
            a.style.padding = '10px 20px';
            a.style.backgroundColor = '#28a745';
            a.style.color = 'white';
            a.style.textDecoration = 'none';
            a.style.borderRadius = '4px';
            a.style.marginTop = '10px';
            
            statusDiv.appendChild(document.createElement('br'));
            statusDiv.appendChild(a);
        }

    </script>
</body>
</html>
